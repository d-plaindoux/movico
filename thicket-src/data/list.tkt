/*
 * Thicket
 * https://github.com/d-plaindoux/thicket
 *
 * Copyright (c) 2015 Didier Plaindoux
 * Licensed under the LGPL2 license.
 */

module Data.List

from Core.Lang import Builder
from Data.Pair import Pair
from Data.Boolean import bool
from Data.Number import number
from Data.Option import option
from Data.Comparable import Comparable
from Data.Hashable import Hashable
from Data.Collection import Collection

type List[a] {
    model Nil
    model Cons {
        head : a
        tail : List[a]
    }
}

class list[a] this:List[a] {
    unbox   : List[a]
    fold    : [b] b -> (a -> list[a] -> b) -> b

    empty   : bool
    length  : number

    reverse : list[a]
    
    (++)    : list[a] -> list[a]
    (+:)    : a -> list[a]
    (:+)    : a -> list[a]

    map     : [b] (a -> b) -> list[b]
    flatmap : [b] (a -> list[b]) -> list[b]

    filter  : (a -> bool) -> list[a]
    find    : (a -> bool) -> option[a]

    foldL   : [b] (b -> a -> b) -> b -> b
    foldR   : [b] (a -> b -> b) -> b -> b

    zip     : [b] list[b] -> ziplist[a b]
    
    collection : Collection[a]
    builder : Builder[a list[a]]
} {
    def unbox = this

    def Nil.fold n c = n
    def Cons.fold n c = c this.head (list this.tail)

    def empty = self fold true (_ _ -> false)

    def length = self foldR (_ r -> r ++) 0

    def reverse = list $ self foldL (b a -> Cons a b) Nil

    def (++) l = self foldR (e r -> list $ Cons e r.unbox) l
    def (+:) a = list $ Cons a this
    def (:+) a = self ++ $ list Nil +: a

    def map f = self foldR (e r -> let ne = f e in list $ Cons ne r.unbox) $ list Nil
    def flatmap f = self foldR (e r -> (f e) ++ r) $ list Nil

    def filter p = self foldR (e r -> (p e) fold (list $ Cons e r.unbox) r) $ list Nil
    def find p = self filter p fold none (a _ -> some a)

    def Nil.foldL _ b = b
    def Cons.foldL f b = f (list this.tail foldL f b) this.head

    def Nil.foldR _ b = b
    def Cons.foldR f b = let r = f this.head b in list this.tail foldR f r

    def Nil.zip l = ziplist Nil
    def Cons.zip l =
        let ifNil = ziplist Nil in
        let ifCons = head tail -> ziplist $ Cons (this.head,head) (list this.tail zip tail unbox) in
            l fold ifNil ifCons

    def collection = Collection self.find 
                                (p -> self filter p collection) 
                                (v -> self +: v collection) 
                                (f -> self map f collection)
                                
    def builder = Builder self (a ->(self :+ a).builder)
}

class ziplist[a b] this:List[(a,b)] {
    unbox : List[(a,b)] 
    unzip : list[a],list[b]     
} {
    def unbox = this
    
    def Nil.unzip = (list Nil),(list Nil)
    def Cons.unzip = 
        let tail = ziplist this.tail unzip in
            (list $ Cons this.head._1 tail._1.unbox),(list $ Cons this.head._2 tail._2.unbox)        
}

def listBuilder : [a] a -> builder[a list[a]] = builder (list Nil).builder ;

adapter list2colleciton : [a] list[a] -> Collection[a] = l -> l.collection
