/*
 * Thicket
 * https://github.com/d-plaindoux/thicket
 *
 * Copyright (c) 2015 Didier Plaindoux
 * Licensed under the LGPL2 license.
 */
 
module Data.Try

from Data.Boolean import bool
from Data.String import string
from Logic.Combinators import I
 
type Try[a] {
    model Success { _ : a }
    model Failure { _ : string }
}

class try[a] this:Try[a] {    
    unbox       : Try[a]
    fold        : [b] (a -> b) -> (string -> b) -> b
    map         : [b] (a -> b) -> try[b]
    flatmap     : [b] (a -> try[b]) -> try[b]
    filter      : (a -> bool) -> try[a]
    recoverWith : (string -> a) -> a
} {
    def unbox = this
    
    def Failure.fold _ f = f this._
    def Success.fold s _ = s this._

    def map f = self fold (s -> let r = f s in success r) failure
    def flatmap f = self fold f failure

    def Failure.filter _ = self
    def Success.filter p = p this._ fold self $ failure "Filter fails"

    def recoverWith = self fold I
}

def success : [a] a -> try[a] = a -> try $ Success a
def failure : [a] string -> try[a] = a -> try $ Failure a

adapter try2option : [a] try[a] -> option[a] = t -> t fold some (_ -> none)