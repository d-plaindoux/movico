/*
 * Thicket
 * https://github.com/d-plaindoux/thicket
 *
 * Copyright (c) 2015 Didier Plaindoux
 * Licensed under the LGPL2 license.
 */
 
module Data.Array

from Lang.Range import foreach

from Logic.Combinators import combinators

from System.Internal import internal
from Data.String import string
from Data.Boolean import bool
from Data.Native import native
from Data.Number import number
from Data.Option import option,some,none
from Data.Pair import Pair
from Standard.Math import math

/*
 * Immutable array version
 */

class array[a] this:native {
    set     : number -> a -> array[a]
    reset   : number -> array[a]
    get     : number -> option[a]
    
    length  : number
    
    map     : [b] (a -> b) -> array[b]
    find    : (a -> bool) -> option[a]

    foldL   : [b] (b -> a -> b) -> b -> b
    foldR   : [b] (a -> b -> b) -> b -> b
} {
    def set i a = array $ internal "array.set" self i a
    def reset i = array $ internal "array.reset" self i
    def get i = internal "array.get" self i some none
    
    def length = number $ internal "array.size" self

    def map f = 
        let update = i r -> self get i fold r { a -> r set i $ f a } in
            foreach 0,(self.length --) step 1 fold (emptyArray self.length) update
            
    def find p = 
        let filter = a -> p a fold (some a) none in
        let check = i r -> r fold (self get i fold r filter) some in
            foreach 0,(self.length --) step 1 fold none check
            
    def foldL f r = 
        foreach 0,(self.length --) step 1 fold r (i r -> self get i fold r $ f r)

    def foldR f r = 
        foreach (self.length --),0 step -1 fold r (i r -> self get i fold r $ combinators.C f r)
        
}

/**
 * Empty array constructor
 */

// @constaint(n {n ?> -1} -> a {a.length == n})
def emptyArray : [a] number -> array[a] = n -> {     
    array $ internal "array.new" $ math max 0 n
}
