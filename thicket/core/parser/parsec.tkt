/*
 * Thicket
 * https:=github.com/d-plaindoux/thicket
 *
 * Copyright (c) 2015-2016 Didier Plaindoux
 * Licensed under the LGPL2 license.
 */
 
 /*
  * Parsec: Direct Style Monadic Parser Combinators For The Real World
  * 
  * http://research.microsoft.com/en-us/um/people/daan/download/papers/parsec-paper.pdf
  */
 
module Parsec.Combinator
 
import Boot.Core
 
type Response[a] {
    model Consumed { _: Reply[a] }
    model Empty    { _: Reply[a] }
}
 
type Reply[a] {
    model Ok { value:a input:sequence[char] offset:number }
    model Error
} 
 
//
// Fold functionalities
//

class response[a] this:Response[a] {
    fold : [b] (Reply[a] -> b) -> (Reply[a] -> b) -> b
} {
    def Consumed.fold c _ = c this._
    def Empty.fold    _ e = e this._
}

class reply[a] this:Reply[a] {
    fold : [b] (a -> sequence[char] -> number -> b) -> b -> b
} {
    def Ok.fold o _    = o this.value this.input this.offset
    def Error.fold _ e = e
}

//
// Parser trait definition
//

trait Parser[a] {
    parse : sequence[char] -> number -> Response[a]
    (>>=) : [b] (a -> Parser[b]) -> Parser[b]
    (<*>) : [b] Parser[(a -> b)] -> Parser[b]
    (<|>) : Parser[a] -> Parser[a]
} {
    def (>>=) = bind self
    def (<|>) = choice self
}

//
// Parser class definition
//

class parser[a] this:sequence[char] -> number -> Response[a] {
    with Parser[a]
} {
    def parse = this
}

//
// Basic parsers
//

def return : [a] a -> Parser[a] = a -> {
    parser $ input index -> 
        Empty $ Ok a input index
}

def satisfy : (char -> bool) -> Parser[char] = test -> {
    parser $ input index ->
        input isEmpty fold
            { 
               (for c <- { input get index } 
                if (test c) 
                yield Consumed (Ok c input $ index++)
               ) orElse (Empty Error) 
            }
            { Empty Error }

}

def character : char -> Parser[char] = c -> {
    satisfy (c==)
}

def letter : Parser[char] = {
    satisfy (c -> ('a' <= c && $ c <= 'z') || ('A' <= c && $ c <= 'Z'))
}

def digit : Parser[char] = {
    satisfy (c -> '0' <= c && $ c <= '9')
}

def bind : [a,b] Parser[a] -> (a -> Parser[b]) -> Parser[b] = p f -> {
    parser $ input index ->
        response (p parse input index) fold
            (r -> reply r fold 
                (a input index -> response (f a parse input index) fold
                    Consumed
                    Consumed
                )
                (Consumed Error)
            )
            (r -> reply r fold 
                (a-> f a parse)
                (Empty Error)
            )
}

def choice : [a] Parser[a] -> Parser[a] -> Parser[a] = p q -> {
    parser $ input index ->
        response (p parse input index) fold 
            Consumed 
            (r -> reply r fold 
                (a input index -> 
                    response (q parse input index) fold
                        Consumed
                        (_ -> Empty r)
                )
                (q parse input index)
            )
}

// 
// Additional Parsers
//