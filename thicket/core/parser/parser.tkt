/*
 * Thicket
 * https:=github.com/d-plaindoux/thicket
 *
 * Copyright (c) 2015-2016 Didier Plaindoux
 * Licensed under the LGPL2 license.
 */
 
 module Parser.Combinator

from Data.Unit import unit
from Data.String import string
from Data.Number import number, (-)
from Data.Boolean import bool
from Data.Character import char
from Data.Pair import Pair
from Data.List import list, emptyList
from Data.Option import option, some, none
from Data.Sequence import sequence
from Data.Monadic import Monadic
from Lang.When import when
from Lang.Do import do
from System.Console import console

typedef Parsing[a,b] = sequence[b] -> number -> option[(a,number)]

trait Parser[a] {
    with Monadic[Parser,a]
    
    parse : Parsing[a,char]
    
    (~)   : [b] Parser[b] -> Parser[(a,b)] 
    (~>)  : [b] Parser[b] -> Parser[b] 
    (<~)  : [b] Parser[b] -> Parser[a] 
    (|)   : Parser[a] -> Parser[a]  // No super type allowed
    (+)   : Parser[list[a]]
    (?)   : Parser[option[a]]
    (*)   : Parser[option[list[a]]]
} {
    def map     f = parser $ s n -> self parse s n map     $ r -> (f r._1),r._2
    def flatmap f = parser $ s n -> self parse s n flatmap $ r -> f r._1 parse s r._2
    def filter  p = parser $ s n -> self parse s n flatmap $ r -> p r._1 fold (some r) none
    
    def (~)  p = self flatmap $ a -> p map $ b -> (a,b)
    def (~>) p = self ~ p map (r -> r._2)
    def (<~) p = self ~ p map (r -> r._1)
    def (|)    = choiceParser self
    def (+)    = self ~ (lazy $ self *) map $ r -> r._2 orElse emptyList +: r._1
    def (?)    = self map some | (return none)
    def (*)    = self + ?
}

class parser[a] this:Parsing[a,char] {
    with Parser[a]
} {
    def parse = this
}

def return : [a] a -> Parser[a] = a -> {
    parser $ s n -> some (a,n)
}

def consume : [a] Parser[a] -> Parser[unit] = p -> {
    p map $ _ -> ()
}

def lazy : [a] Parser[a] -> Parser[a] = {
    do { } return
}

// 
// Combinators
//

def choiceParser : [a] Parser[a] -> Parser[a] -> Parser[a] = p1 p2 -> {
    parser $ s n -> 
        p1 parse s n fold (p2 parse s n) some
}

def mayBeOneParser: [a] Parser[a] -> Parser[option[a]] = p -> {
    parser $ s n -> 
        some (p parse s n fold (none,n) $ r -> (some r._1),r._2)
}

def characterParser : (char -> bool) -> Parser[char] = accept -> {
    parser $ s n ->
        for c <- (s get n)
        if accept c
        yield c,(n+1)
}

def digit : Parser[char] = { 
    characterParser $ c -> ('0' <= c) && (c <= '9') 
} 

def lowerCase : Parser[char] = { 
    characterParser $ c -> ('a' <= c) && (c <= 'z') 
} 

def upperCase : Parser[char] = { 
    characterParser $ c -> ('A' <= c) && (c <= 'Z') 
} 

def letter : Parser[char] = {
    lowerCase | upperCase
}

def notChar : char -> Parser[char] = c -> {
    characterParser (c!=)
} 

def aChar : char -> Parser[char] = c -> {
    characterParser (c==)
} 

def aString : string -> Parser[unit] = w -> {
    parser $ s n ->
        0 to (w.length-1) fold
            (some $ unit,n) 
            (r i ->
                for _  <- r
                    c1 <- (s get (n+i))
                    c2 <- (w get i)
                if c1 == c2
                yield unit,(n+i))
}

def charLiteral : Parser[char] = {
    let anyChar = (aChar '\\' ~> $ aChar '\'') | (notChar '\'') in 
        (aChar '\'') ~> anyChar <~ (aChar '\'')
}

def stringLiteral : Parser[string] = {
    let anyChar = (aChar '\\' ~> $ aChar '"') | (notChar '"') in 
        (aChar '"') ~> (anyChar*) <~ (aChar '"') map
        $ o -> o fold "" $ l -> l foldR (c r -> r + c) ""
}

def numberLiteral : Parser[number] = {
    digit+ map 
    $ l -> l foldR (c r -> r+c) "" toNumber fold 0 (r -> r)
}

/* Example : Expressions parser

def expressions : Parser[number] = {
    expression ~ expressionsOp map (r -> r._2 r._1)
}

def expressionsOp : Parser[(number -> number)] = {
    (aChar '+' ~> expressions map $ r e:number -> e+r) 
  | (aChar '-' ~> expressions map $ r e:number -> e-r) 
  | (aChar '*' ~> expressions map $ r e:number -> e*r) 
  | (aChar '/' ~> expressions map $ r e:number -> e/r) 
  | (return                       $ e -> e)
}

def expression : Parser[number] = {
    ((aChar '(') ~> expressions <~ (aChar ')'))
  | numberLiteral
}

*/