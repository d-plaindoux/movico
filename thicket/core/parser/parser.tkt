module Parser.Combinator

from Data.Unit import unit
from Data.String import string
from Data.Number import number, (-)
from Data.Boolean import bool
from Data.Character import char
from Data.Pair import Pair
from Data.List import list, emptyList
from Data.Option import option, some, none
from Data.Sequence import sequence
from Data.Monadic import Monadic
from Lang.When import when
from Lang.Do import do
from System.Console import console

typedef Parsing[a] = sequence[char] -> number -> option[(a,number)]

trait Parser[a] {
    with Monadic[Parser,a]
    
    parse : Parsing[a]
    
    (~)   : [b] Parser[b] -> Parser[(a,b)] 
    (~>)  : [b] Parser[b] -> Parser[b] 
    (<~)  : [b] Parser[b] -> Parser[a] 
    (+)   : Parser[list[a]]
    (?)   : Parser[option[a]]
    (*)   : Parser[option[list[a]]]
    (|)   : Parser[a] -> Parser[a]  // No super type allowed
} {
    def map     f = parser $ s n -> self parse s n map $ r -> (f r._1),r._2
    def flatmap f = parser $ s n -> self parse s n flatmap $ r -> f r._1 parse s r._2
    def filter  p = parser $ s n -> self parse s n flatmap $ r -> when (p r._1) then (some r) else none
    
    def (~)  p = sequenceParser      self p
    def (~>) p = sequenceRightParser self p
    def (<~) p = sequenceLeftParser  self p
    def (?)    = mayBeOneParser      self
    def (+)    = manyOneParser       self
    def (*)    = mayBeOneParser      (manyOneParser self)
    def (|)  p = choiceParser        self p
}

class parser[a] this:Parsing[a] {
    with Parser[a]
} {
    def parse s n = this s n
}

def lambda : Parser[unit] = {
    parser $ s n -> some ((),n)
}

def trace : [a] string -> Parser[a] -> Parser[a] = name p -> {
    parser $ s n ->
        do {
            console.log name
        } return p parse s n
}

def consume : [a] Parser[a] -> Parser[unit] = p -> {
    p map $ _ -> ()
}

// 
// Combinators
//

def sequenceParser: [a,b] Parser[a] -> Parser[b] -> Parser[(a,b)] = p1 p2 -> {
    parser $ s n ->
        for ra <- { p1 parse s n     }
            rb <- { p2 parse s ra._2 }
        yield (ra._1,rb._1),rb._2
}

def sequenceLeftParser: [a,b] Parser[a] -> Parser[b] -> Parser[a] = p1 p2 -> {
    sequenceParser p1 p2 map (r -> r._1)
}

def sequenceRightParser: [a,b] Parser[a] -> Parser[b] -> Parser[b] = p1 p2 -> {
    sequenceParser p1 p2 map (r -> r._2)
}

def choiceParser : [a] Parser[a] -> Parser[a] -> Parser[a] = p1 p2 -> {
    parser $ s n ->
        p1 parse s n fold (p2 parse s n) some
}

def mayBeOneParser: [a] Parser[a] -> Parser[option[a]] = p -> {
    parser $ s n -> 
        some (p parse s n fold (none,n) $ r -> (some r._1),r._2)
}

def manyOneParser: [a] Parser[a] -> Parser[list[a]] = p -> {
    parser $ s n ->
        p parse s n map 
        $ r -> manyOneParser p parse s r._2 
               fold ((emptyList +: r._1),r._2) 
                     (t -> (t._1 +: r._1),t._2)
}

def characterParser : (char -> bool) -> Parser[char] = accept -> {
    parser $ s n ->
        s get n flatmap
        $ c -> when (accept c)
               then { some (c,(n+1)) }
               else none
}

def digit : Parser[char] = { 
    characterParser $ c -> ('0' <= c) && (c <= '9') 
} 

def lowerCase : Parser[char] = { 
    characterParser $ c -> ('a' <= c) && (c <= 'z') 
} 

def upperCase : Parser[char] = { 
    characterParser $ c -> ('A' <= c) && (c <= 'Z') 
} 

def letter : Parser[char] = {
    lowerCase | upperCase
}

def notChar : char -> Parser[char] = c -> {
    characterParser (c!=)
} 

def aChar : char -> Parser[char] = c -> {
    characterParser (c==)
} 

def aString : string -> Parser[unit] = s -> {
    s toList foldR (c p -> consume (aChar c) <~ p) lambda
}

def charLiteral : Parser[char] = {
    let anyChar = (aChar '\\' ~> $ aChar '\'') | (notChar '\'') in 
        (aChar '\'') ~> anyChar <~ (aChar '\'')
}

def stringLiteral : Parser[string] = {
    let anyChar = (aChar '\\' ~> $ aChar '"') | (notChar '"') in 
        (aChar '"') ~> (anyChar*) <~ (aChar '"') map
        $ o -> o fold "" $ l -> l foldR (c r -> r + c) ""
}

def numberLiteral : Parser[number] = {
    digit+ map 
    $ l -> l foldR (c r -> r+c) "" toNumber fold 0 (r -> r)
}

/* Example : Expressions parser

def expressions : Parser[number] = {
    expression ~ expressionsOp map (r -> r._2 r._1)
}

def expressionsOp : Parser[(number -> number)] = {
    (aChar '+' ~> expressions map $ r e:number -> e+r) 
  | (aChar '-' ~> expressions map $ r e:number -> e-r) 
  | (aChar '*' ~> expressions map $ r e:number -> e*r) 
  | (aChar '/' ~> expressions map $ r e:number -> e/r) 
  | (lambda                   map $ _ e:number -> e)
}

def expression : Parser[number] = {
    ((aChar '(') ~> expressions <~ (aChar ')'))
  | numberLiteral
}

*/