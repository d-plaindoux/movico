/*
 * Movico
 * https://github.com/d-plaindoux/movico
 *
 * Copyright (c) 2015 Didier Plaindoux
 * Licensed under the LGPL2 license.
 */
 
module Data.Map
 
from Data.Boolean import bool
from Data.List import list
from Data.Number import number
from Data.Option import option
from Data.Pair import Pair
from Data.Types import comparable hashable

class hashmap[k v] this:List[(number,(k,v))] {
  unbox : List[(number,(k,v))]
  (?)   : comparable[k] -> option[v]
  (+)   : hashable[k] -> v -> hashmap[k v]
  keys  : list[k]
  values: list[v]
} {
  def unbox = this

  def (?) k = list this find (fun e -> k == e._2._1) map (fun e -> e._2._2)
  
  def Nil.(+) k v =
      let entry = (k hash),((k unbox),v) in
          self $ Cons entry Nil

  def Nil.keys = list Nil
  def Cons.keys = list $ Cons this.head._2._1 $ self this.tail keys unbox

  def Nil.values = list Nil
  def Cons.values = list $ Cons this.head._2._2 $ self this.tail values unbox

  def Cons.(+) k v = 
      let entry = (k hash),((k unbox),v) in
      let equal = fun e -> k hash == this.head._1 fold (Cons entry this.tail) e in
      let minimum = fun e -> k hash << this.head._1 fold (Cons entry this) e in
      let maximum = Cons this.head $ self this.tail + k v unbox in
          self $ equal (minimum maximum)          
}

def emptyMap : hashmap = hashmap Nil