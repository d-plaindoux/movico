/*
 * Movico
 * https://github.com/d-plaindoux/movico
 *
 * Copyright (c) 2015 Didier Plaindoux
 * Licensed under the LGPL2 license.
 */

module Data.List

from Data.Pair import Pair
from Data.Boolean import bool
from Data.Number import number
from Data.Option import option
from Data.Types import Collection

type List[a] {
    model Nil
    model Cons {
        head : a
        tail : List[a]
    }
}

class list[a] this:List[a] {
    unbox   : List[a]
    fold    : [b] b -> (a -> list[a] -> b) -> b

    isEmpty : bool
    length  : number

    reverse : list[a]
    (++)    : list[a] -> list[a]
    (+:)    : a -> list[a]
    (:+)    : a -> list[a]

    map     : [b] (a -> b) -> list[b]
    flatmap : [b] (a -> list[b]) -> list[b]

    filter  : (a -> bool) -> list[a]
    find    : (a -> bool) -> option[a]

    foldL   : [b] (b -> a -> b) -> b -> b
    foldR   : [b] (a -> b -> b) -> b -> b

    zip     : [b] list[b] -> ziplist[a b]
    
    collection : Collection[a]
} {
    def unbox = this

    def Nil.fold n c = n
    def Cons.fold n c = c this.head (self this.tail)

    def Nil.isEmpty = bool True
    def Cons.isEmpty = bool False

    def length = self foldR (_ r -> 1 + r) 0

    def reverse = self $ self foldL (b a -> Cons a b) Nil

    def (+:) a = self $ Cons a this

    def Nil.(++) l = l
    def Cons.(++) l = self $ Cons this.head $ self this.tail ++ l unbox

    def Nil.(:+) = self +:
    def Cons.(:+) a = self $ Cons this.head $ self this.tail :+ a unbox

    def Nil.map _ = list Nil
    def Cons.map f = list $ Cons (f this.head) $ self this.tail map f unbox

    def Nil.flatmap _ = list Nil
    def Cons.flatmap f = (f this.head) ++ (self this.tail flatmap f)

    def Nil.filter _ = self
    def Cons.filter p =
        let tail = self this.tail filter p in
            (p this.head) fold (self $ Cons this.head $ tail.unbox) tail
            
    def find p = self filter p fold none (a _ -> some a)

    def Nil.foldL _ b = b
    def Cons.foldL f b = f (self this.tail foldL f b) this.head

    def Nil.foldR _ b = b
    def Cons.foldR f b = self this.tail foldR f $ f this.head b

    def Nil.zip l = ziplist Nil
    def Cons.zip l =
        let ifNil = ziplist Nil in
        let ifCons = head tail -> ziplist $ Cons (this.head,head) (self this.tail zip tail unbox) in
            l fold ifNil ifCons

    def collection = Collection self.find 
                                (p -> self filter p collection) 
                                (v -> self +: v collection) 
                                (f -> self map f collection)
}

class ziplist[a b] this:List[(a,b)] {
    unbox : List[(a,b)] 
    unzip : list[a],list[b]     
} {
    def unbox = this
    
    def Nil.unzip = (list Nil),(list Nil)
    def Cons.unzip = 
        let tail = self this.tail unzip in
            (list $ Cons this.head._1 tail._1.unbox),(list $ Cons this.head._2 tail._2.unbox)        
}

def nil : list = 
    list Nil
